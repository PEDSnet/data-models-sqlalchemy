machine:
  services:
    - docker
  python:
    version: 2.7.3
  environment:
    # Make CircleCI specific environment variables more generic.
    BUILD_NUM: "${CIRCLE_BUILD_NUM}"
    COMMIT_SHA1: "${CIRCLE_SHA1}"
    BRANCH: "${CIRCLE_BRANCH}"
    APP_NAME: "${CIRCLE_PROJECT_REPONAME}"
    ARTIFACT_DIR: "${CIRCLE_ARTIFACTS}"
    TEST_OUTPUT_DIR: "${CIRCLE_TEST_REPORTS}"
    URL_TEMPLATE: "http://127.0.0.1:8123/schemata/{model}/{version}?format=json"
    DMSA_TEST_CONTAINER_URL: "http://127.0.0.1:5000/"

checkout:
  post:
    # Set git file mtimes to commit times so docker build recognizes cache.
    - ./ci/git-set-file-times.pl

dependencies:
  cache_directories:
    # Add a cache directory to save docker images to.
    - "~/docker"
    # Add a cache directory for the jq install.
    - "~/bin"
  override:
    # Install pygraphviz pointing specifically to the library.
    # see: https://github.com/pygraphviz/pygraphviz/issues/71
    - pip install pygraphviz
      --install-option="--include-path=/usr/include/graphviz"
      --install-option="--library-path=/usr/lib/graphviz/"
    # Install remaining requirements.
    - pip install -r requirements.txt
    # Install dmsa app.
    - python setup.py install
    # Install tox for testing.
    - pip install tox
    # Install awscli for AWS integration, wheel and twine for PyPi,
    # python-coveralls for code coverage reporting, and docker-py and requests
    # for integration testing of the docker container.
    - pip install awscli wheel twine python-coveralls docker-py requests
    # Install jq for command line JSON parsing in deployment.
    - mkdir -p ~/bin; if [[ ! -e ~/bin/jq ]]; then curl -L -o ~/bin/jq
      http://stedolan.github.io/jq/download/linux64/jq &&
      chmod 0755 ~/bin/jq; fi
    # Load dmsa docker image from previous build. This allows docker to use
    # the cached layers of dmsa when building.
    - if [[ -e ~/docker/dmsa.tar ]]; then docker load --input
      ~/docker/dmsa.tar; fi
    # Load data-models-service (dms) image if it exists in cache and pull it.
    - if [[ -e ~/docker/dms.tar ]]; then docker load --input
      ~/docker/dms.tar; fi; docker pull dbhi/data-models
    # Build new dmsa image, using cached layers from last image.
    - docker build -t
      dbhi/data-models-sqlalchemy:$(./ci/version.sh | sed "s/+/-/g") .
    # Save new dmsa image to cache for next build.
    - mkdir -p ~/docker; docker save dbhi/data-models-sqlalchemy >
      ~/docker/dmsa.tar
    # Save dms image.
    - docker save dbhi/data-models > ~/docker/dms.tar

test:
  override:
    # Run the dms service locally.
    - docker run -d -p "8123:8123" dbhi/data-models; sleep 10
    # Run the dmsa container locally.
    - docker run -d -p "5000:80"
      dbhi/data-models-sqlalchemy:$(./ci/version.sh | sed "s/+/-/g"); sleep 10
    # Unit testing with coverage and xml output.
    - mkdir -p "${TEST_OUTPUT_DIR}/nose"; nosetests --with-coverage
      --cover-package=dmsa --cover-html --cover-html-dir="${ARTIFACT_DIR}"
      --with-xunit --xunit-file="${TEST_OUTPUT_DIR}/nose/nosetests.xml"
    # Integration testing of the running container service.
    - nosetests dmsa.tests.container_integration
    # Save DDL to artifact directory.
    - mkdir -p "${ARTIFACT_DIR}/ddl"
    - python dmsa/tests/output_all_ddl.py
      "${ARTIFACT_DIR}/ddl/dmsa_$(./ci/version.sh)_all_ddl.sql"
  post:
    # Publish coverage report to Coveralls (requires COVERALLS_REPO_TOKEN).
    - coveralls

deployment:
  all:
    branch: /.*/
    commands:
      # See below file for detailed notes on deployment.
      - ./ci/deploy.sh
